package docker

import (
	"context"

	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/container"
	"github.com/docker/docker/api/types/network"
	"github.com/docker/docker/client"
	"github.com/ipaas-org/ipaas-backend/model"
	"github.com/ipaas-org/ipaas-backend/services/serviceManager"
)

var _ serviceManager.ServiceManager = new(DockerApplicationManager)

type DockerApplicationManager struct {
	cli *client.Client
}

func NewDockerApplicationManager(ctx context.Context) (*DockerApplicationManager, error) {
	c := new(DockerApplicationManager)
	var err error
	//creating docker client from env

	c.cli, err = client.NewClientWithOpts(client.FromEnv)
	c.cli.NegotiateAPIVersion(ctx)
	if err != nil {
		return nil, err
	}

	return c, nil
}

func (d DockerApplicationManager) convertModelEnvToDockerEnv(envs []model.KeyValue) []string {
	var dockerEnvs []string
	for _, env := range envs {
		dockerEnvs = append(dockerEnvs, env.Key+"="+env.Value)
	}
	return dockerEnvs
}

func (d DockerApplicationManager) convertModelLablesToDockerLabels(labels []model.KeyValue) map[string]string {
	dockerLabels := make(map[string]string)
	for _, label := range labels {
		dockerLabels[label.Key] = label.Value
	}
	return dockerLabels
}

// port is not needed cause it will be handled by traefik
// name will be autogenerated with an uuid
func (d DockerApplicationManager) CreateNewService(ctx context.Context, name, image string, envs, labels []model.KeyValue) (*model.Container, error) {
	containerConfig := &container.Config{
		Hostname: name,
		Image:    image,
		Env:      d.convertModelEnvToDockerEnv(envs),
		Labels:   d.convertModelLablesToDockerLabels(labels),
	}

	//TODO: should use on failure policy
	hostConfig := &container.HostConfig{
		RestartPolicy: container.RestartPolicy{
			Name:              "on-failure",
			MaximumRetryCount: 3,
		},
		Resources: container.Resources{
			CPUPeriod:         100000,             //100ms
			CPUQuota:          25000,              //25% of a vCPU
			Memory:            1024 * 1024 * 1024, //1GB
			MemoryReservation: 512 * 1024 * 1024,  //soft limit to 512 MB
		},
	}

	containerBody, err := d.cli.ContainerCreate(
		ctx, containerConfig, hostConfig, nil, nil, name)

	if err != nil {
		return nil, err
	}
	container := new(model.Container)
	container.ID = containerBody.ID
	container.Name = name
	container.ImageID = image
	container.Labels = labels
	container.Status = model.ContainerCreatedStatus
	return container, nil
}

func (d DockerApplicationManager) StartServiceByID(ctx context.Context, id string) error {
	return d.cli.ContainerStart(ctx, id, container.StartOptions{})
}

func (d DockerApplicationManager) StopServiceByID(ctx context.Context, id string) error {
	timeout := 10
	return d.cli.ContainerStop(ctx, id, container.StopOptions{
		Timeout: &timeout,
	})
}

func (d DockerApplicationManager) RemoveServiceByID(ctx context.Context, id string, forced bool) error {
	return d.cli.ContainerRemove(ctx, id, container.RemoveOptions{
		Force: forced,
	})
}

func (d DockerApplicationManager) CreateNewNetwork(ctx context.Context, name string) (string, error) {
	resp, err := d.cli.NetworkCreate(ctx, name, types.NetworkCreate{
		Driver:     "bridge",
		Attachable: true,
	})
	return resp.ID, err
}

func (d DockerApplicationManager) RemoveNetwork(ctx context.Context, id string) error {
	return d.cli.NetworkRemove(ctx, id)
}

func (d DockerApplicationManager) ConnectServiceToNetwork(ctx context.Context, id string, networkID, dnsAlias string) error {
	return d.cli.NetworkConnect(ctx, networkID, id, &network.EndpointSettings{
		Aliases: []string{dnsAlias},
	})
}

func (d DockerApplicationManager) DisconnectContainerFromNetwork(ctx context.Context, id string, networkID string) error {
	return d.cli.NetworkDisconnect(ctx, networkID, id, true)
}

func (d DockerApplicationManager) RemoveImageByID(ctx context.Context, id string) error {
	_, err := d.cli.ImageRemove(ctx, id, types.ImageRemoveOptions{
		Force: true,
	})
	return err
}
