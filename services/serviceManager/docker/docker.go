package docker

import (
	"context"

	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/container"
	"github.com/docker/docker/api/types/network"
	"github.com/docker/docker/client"
	"github.com/google/uuid"
	"github.com/ipaas-org/ipaas-backend/model"
	"github.com/ipaas-org/ipaas-backend/services/serviceManager"
)

var _ serviceManager.ServiceManager = new(DockerApplicationManager)

type DockerApplicationManager struct {
	cli *client.Client
}

func NewDockerApplicationManager() (*DockerApplicationManager, error) {
	c := new(DockerApplicationManager)
	var err error
	//creating docker client from env
	c.cli, err = client.NewClientWithOpts(client.FromEnv)
	if err != nil {
		return nil, err
	}

	return c, nil
}

func (d DockerApplicationManager) convertModelEnvToDockerEnv(envs []model.KeyValue) []string {
	var dockerEnvs []string
	for _, env := range envs {
		dockerEnvs = append(dockerEnvs, env.Key+"="+env.Value)
	}
	return dockerEnvs
}

// port is not needed cause it will be handled by traefik
// name will be autogenerated with an uuid
func (d DockerApplicationManager) CreateNewContainer(ctx context.Context, hostname, image string, envs, labels []model.KeyValue) (string, string, error) {
	containerConfig := &container.Config{
		Hostname: hostname,
		Image:    image,
		Env:      d.convertModelEnvToDockerEnv(envs),
	}

	//TODO: should use on failure policy
	hostConfig := &container.HostConfig{
		RestartPolicy: container.RestartPolicy{
			Name: "unless-stopped",
		},
	}

	ran, err := uuid.NewRandom()
	if err != nil {
		return "", "", err
	}
	name := ran.String()

	containerBody, err := d.cli.ContainerCreate(
		ctx, containerConfig, hostConfig, nil, nil, name)

	if err != nil {
		return "", "", err
	}

	return containerBody.ID, name, nil
}

func (d DockerApplicationManager) ConnectContainerToNetwork(ctx context.Context, containerID, networkID, dnsAlias string) error {
	return d.cli.NetworkConnect(ctx, networkID, containerID, &network.EndpointSettings{
		Aliases: []string{dnsAlias},
	})
}

func (d DockerApplicationManager) RemoveContainer(ctx context.Context, id string) error {
	return d.cli.ContainerRemove(ctx, id, types.ContainerRemoveOptions{
		Force: true,
	})
}

func (d DockerApplicationManager) StartContainer(ctx context.Context, id string) error {
	return d.cli.ContainerStart(ctx, id, types.ContainerStartOptions{})
}
