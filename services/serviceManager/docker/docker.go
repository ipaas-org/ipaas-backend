package docker

import (
	"context"

	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/container"
	"github.com/docker/docker/api/types/network"
	"github.com/docker/docker/client"
	"github.com/google/uuid"
	"github.com/ipaas-org/ipaas-backend/model"
	"github.com/ipaas-org/ipaas-backend/services/serviceManager"
)

var _ serviceManager.ServiceManager = new(DockerApplicationManager)

type DockerApplicationManager struct {
	cli *client.Client
}

func NewDockerApplicationManager(ctx context.Context) (*DockerApplicationManager, error) {
	c := new(DockerApplicationManager)
	var err error
	//creating docker client from env

	c.cli, err = client.NewClientWithOpts(client.FromEnv)
	c.cli.NegotiateAPIVersion(ctx)
	if err != nil {
		return nil, err
	}

	return c, nil
}

func (d DockerApplicationManager) convertModelEnvToDockerEnv(envs []model.KeyValue) []string {
	var dockerEnvs []string
	for _, env := range envs {
		dockerEnvs = append(dockerEnvs, env.Key+"="+env.Value)
	}
	return dockerEnvs
}

func (d DockerApplicationManager) convertModelLablesToDockerLabels(labels []model.KeyValue) map[string]string {
	dockerLabels := make(map[string]string)
	for _, label := range labels {
		dockerLabels[label.Key] = label.Value
	}
	return dockerLabels
}

// port is not needed cause it will be handled by traefik
// name will be autogenerated with an uuid
func (d DockerApplicationManager) CreateNewContainer(ctx context.Context, image string, envs, labels []model.KeyValue) (*model.Container, error) {
	ran, err := uuid.NewRandom()
	if err != nil {
		return nil, err
	}
	name := ran.String()

	containerConfig := &container.Config{
		Hostname: name,
		Image:    image,
		Env:      d.convertModelEnvToDockerEnv(envs),
		Labels:   d.convertModelLablesToDockerLabels(labels),
	}

	//TODO: should use on failure policy
	hostConfig := &container.HostConfig{
		RestartPolicy: container.RestartPolicy{
			Name: "unless-stopped",
		},
	}

	containerBody, err := d.cli.ContainerCreate(
		ctx, containerConfig, hostConfig, nil, nil, name)

	if err != nil {
		return nil, err
	}
	container := new(model.Container)
	container.ContainerID = containerBody.ID
	container.Name = name
	container.ImageID = image
	container.Envs = envs
	container.Labels = labels
	container.Status = model.ContainerCreatedStatus
	return container, nil
}

func (d DockerApplicationManager) ConnectContainerToNetwork(ctx context.Context, contrainer *model.Container, networkID, dnsAlias string) error {
	return d.cli.NetworkConnect(ctx, networkID, contrainer.ContainerID, &network.EndpointSettings{
		Aliases: []string{dnsAlias},
	})
}

func (d DockerApplicationManager) RemoveContainer(ctx context.Context, container *model.Container) error {
	return d.cli.ContainerRemove(ctx, container.ContainerID, types.ContainerRemoveOptions{
		Force: true,
	})
}

func (d DockerApplicationManager) StartContainer(ctx context.Context, container *model.Container) error {
	return d.cli.ContainerStart(ctx, container.ContainerID, types.ContainerStartOptions{})
}

func (d DockerApplicationManager) CreateNewNetwork(ctx context.Context, name string) (string, error) {
	resp, err := d.cli.NetworkCreate(ctx, name, types.NetworkCreate{
		Driver:     "bridge",
		Attachable: true,
	})
	return resp.ID, err
}

func (d DockerApplicationManager) RemoveNetwork(ctx context.Context, id string) error {
	return d.cli.NetworkRemove(ctx, id)
}
